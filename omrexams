#!/usr/bin/env python3

import click
from datetime import datetime as dt
import dateparser as dp
import yaml
from cli import Generate, Sort, Correct, Mark, MoodleConverter
import pandas as pd
import xlrd
import re
import logging
import click_log
import sys
import os
import math
from tinydb import TinyDB, Query, where

logger = logging.getLogger("omrexams")
click_log.basic_config(logger)

class Datetime(click.ParamType):
    '''
    A datetime object parsed via dateparser.parse.
    '''

    name = 'date'

    def convert(self, value, param, ctx):
        if value is None:
            return value

        if isinstance(value, dt):
            return value

        if not isinstance(value, str):
            self.fail('The provided date is not a string "{datetime_str}'.format(
                datetime_str=value), param, ctx)

        result = dp.parse(value)
        if result is None:
            self.fail('Could not parse datetime string "{datetime_str}"'.format(
                datetime_str=value), param, ctx)
        return result

class OptionRequiredIf(click.Option):
    """
    Option is required if the context has `option` set to `value`
    """

    def __init__(self, *a, **k):
        try:
            option = k.pop('option')            
            value  = k.pop('value')
        except KeyError:
            raise(KeyError("OptionRequiredIf needs the option and value "
                           "keywords arguments"))

        click.Option.__init__(self, *a, **k)
        self._option = option
        self._value = value

    def full_process_value(self, ctx, value):
        value = super(OptionRequiredIf, self).full_process_value(ctx, value)
        if value is None and ctx.params[self._option] == self._value:
            msg = 'Required if --{}={}'.format(self._option, self._value)
            raise click.MissingParameter(ctx=ctx, param=self, message=msg)
        return value

DATETIME = Datetime()

@click.group()
@click.version_option(version='0.1')
@click.option('--debug/--no-debug', default=False)
@click.pass_context
def cli(ctx, debug):
    """Manage multiple-choice OMR exams.
    """
    if not debug:
        logger.setLevel(logging.ERROR)
    else:
        logger.setLevel(logging.WARN)

@cli.command()
@click.option('--config', type=click.Path(exists=True, resolve_path=True), required=True, default=os.path.join('.', 'config.yaml'))
@click.option('--students', '-s', type=click.Path(exists=True, resolve_path=True), required=False)
@click.argument('questions_dir', type=click.Path(exists=True, file_okay=False, resolve_path=True), default=os.path.join('.', 'questions'), required=True)
@click.option('--count', '-n', type=int, option='students', value=None, cls=OptionRequiredIf)
@click.option('--serial', type=int, default=1)
@click.option('--output_prefix', '-o', type=click.Path(resolve_path=True), required=False, 
    help='The output prefix (i.e., the name of the pdf and json data files) [default: \'exam-{date}{{.pdf|.json}}\'')
@click.option('--date', '-d', type=DATETIME, prompt='Enter the exam date',  
    default=lambda: dt.now().strftime("%Y-%m-%d"))
@click.option('--seed', '-r', type=int, default=int(dt.now().strftime('%s')))
@click.option('--additional', '-a', type=int, required=False, default=0, help='Number of additional exam sheets')
@click.option('--oneparchoices', '-opc', is_flag=True, type=bool, required=False, help='If set, choices are constrained to be in the same paragraph', default=None)
@click.option('--paper', '-p', type=click.Choice(['A4', 'A3'], case_sensitive=False), default='A4', required=False)
@click.option('--yes', '-y', is_flag=True, type=bool, required=False, default=False, help='Answer yes to all prompt requests')
@click.pass_context
def generate(ctx, config, students, questions_dir, count, serial, output_prefix, date, seed, additional, oneparchoices, paper, yes):
    """
    Generates the set of exams for the given amount of students (either personalized or anonymous).
    """
    config_file = config
    with open(config_file, 'r') as f:
        config = yaml.load(f, Loader=yaml.Loader)
    config['basedir'] = os.path.dirname(config_file)

    if not output_prefix:
        output_prefix = 'exam-{}'.format(date.strftime("%Y-%m-%d"))

    if oneparchoices is None:
        oneparchoices = config.get('choices', {}).get('oneparchoices', False)

    if additional is None and students is not None:
        additional = click.prompt("Generate a number of additional exams?", default=5)

    if paper is None:
        paper = config.get('paper', 'A4')
    paper = paper.upper()    

    if os.path.exists("{}.pdf".format(output_prefix)):
        if yes or click.confirm("Data output {}.pdf exists, overwrite it?".format(output_prefix), default=True):
            os.remove("{}.pdf".format(output_prefix))
        else:
            click.secho("Nothing done", fg='bright_yellow')
            sys.exit(0)
    
    if os.path.exists("{}.json".format(output_prefix)):
        if yes or click.confirm("Data output {}.json exists, overwrite it?".format(output_prefix), default=True):
            os.remove("{}.json".format(output_prefix))
        else:
            click.secho("Nothing done", fg='bright_yellow')
            sys.exit(0)

    if students:
        try:    
            click.secho('Reading excel file', fg='red', underline=True)
            skip = 0
            # check whether the file needs to be partially skipped
            if 'data_marker' in config['excel']:
                marker = config['excel']['data_marker'].get('skip_until')
                column = config['excel'].get('on_column', 0)
                click.secho('Searching for data marker "{} in column {}"'.format(marker, column), fg='cyan')
                wb = xlrd.open_workbook(students)
                sheet = wb.sheet_by_index(0)
                for i in range(sheet.nrows):
                    row = sheet.row(i)
                    cell = row[column]
                    if re.match(marker, cell.value):
                        skip = i + 1
                        break
            if skip > 0:
                click.secho('Skipping {} rows'.format(skip), fg='cyan')
            student_list = pd.read_excel(students, skiprows=skip)
            fields = config['excel']['fields']
            student_list[fields.get('fullname', 'Full Name')] = student_list[fields.get('name')] + ' ' + student_list[fields.get('surname')]
            student_list.reset_index(inplace=True)
            student_list = [tuple(r) for r in student_list[[fields.get('id'), fields.get('fullname', 'Full Name')]].to_records(index=False)] 
            click.secho('Processing done, {} students found'.format(len(student_list)), fg='cyan')
            if additional > 0:                
                student_list += [(i, "Additional student") for i in range(additional)]
                click.secho('Added further {} students'.format(additional), fg='cyan')
        except Exception as e:
            logger.error("While reading the students excel file {filename}: {}".format(str(e), filename=students))
            sys.exit(-1)
    else:
        click.secho('Creating anonymous exams for {} students'.format(count), fg='red', underline=True)
        click.secho('Starting serials from {}'.format(serial), fg='cyan')
        f = "{{:0{}}}".format(math.ceil(math.log10(serial + count)))
        student_list = list(map(lambda s: (f.format(s), ""), range(serial, serial + count)))
    click.secho('Seed used for the random generator {}'.format(seed), fg='magenta')

    generator = Generate(config, questions_dir, output_prefix, students=student_list, 
                         date=date, seed=seed, oneparchoices=oneparchoices, paper=paper)
    generator.process()

@cli.command()
@click.option('--config', type=click.Path(exists=True, resolve_path=True), required=True, default=os.path.join('.', 'config.yaml'))
@click.argument('questions_dir', type=click.Path(exists=True, file_okay=False, resolve_path=True))
@click.option('--oneparchoices', '-opc', is_flag=True, type=bool, required=False, help='If set, choices are constrained to be in the same paragraph', default=None)
@click.option('--output', '-o', type=click.Path(resolve_path=True), default=os.path.join('.', 'exam-test.pdf'))
@click.option('--yes', '-y', is_flag=True, type=bool, required=False, default=False, help='Answer yes to all prompt requests')
@click.pass_context
def test(ctx, config, questions_dir, oneparchoices, output, yes):
    """
    Generates a comprehensive pdf file with all the questions.
    """
    config_file = config
    with open(config_file, 'r') as f:
        config = yaml.load(f, Loader=yaml.Loader)
    config['basedir'] = os.path.dirname(config_file)

    if oneparchoices is None:
        oneparchoices = config.get('choices', {}).get('oneparchoices', False)

    if os.path.exists(output):
        if yes or click.confirm("Data output {} exists, overwrite it?".format(output), default=True):
            os.remove(output)
        else:
            click.secho("Nothing done", fg='bright_yellow')
            sys.exit(0)

    generator = Generate(config, questions_dir, ".".join(output.split(".")[:-1]), test=True, oneparchoices=oneparchoices)
    generator.process()

@cli.command()
@click.argument('scanned', type=click.Path(exists=True, file_okay=True, dir_okay=True, resolve_path=True),  nargs=-1, required=True)
@click.option('--sorted_dir', '-s', type=click.Path(exists=False, file_okay=False, resolve_path=True), default='sorted', prompt='Enter the directory name where to store the sorted exams')
@click.option('--datafile', '-d', type=click.Path(exists=True, file_okay=True, dir_okay=False, resolve_path=True), required=False)
@click.option('--resolution', '-r', default=300)
@click.option('--paper', '-p', type=click.Choice(['A4', 'A3'], case_sensitive=False), default='A4', required=False)
@click.option('--yes', '-y', is_flag=True, type=bool, required=False, default=False, help='Answer yes to all prompt requests')
@click.pass_context
def sort(ctx, scanned, sorted_dir, datafile, resolution, paper, yes):
    """
    Sorts a set of pdf scanned documents into a series of png images, one for each sheet.
    """
    if os.path.exists(sorted_dir):
        if yes or click.confirm("Sorted directory {} exists, overwrite its content?".format(sorted_dir), default=True):
            pass
        else:
            click.secho("Nothing done", fg='bright_yellow')
            sys.exit(0)

    sorter = Sort(scanned, sorted_dir, datafile)
    sorter.sort(resolution, paper.upper())


@cli.command()
@click.argument('sorted_dir', type=click.Path(exists=True, file_okay=False, resolve_path=True), default='sorted')
@click.option('--corrected', '-c', type=click.Path(exists=False, file_okay=True, resolve_path=True), default=os.path.join('.', 'corrected-exam.pdf'))
@click.option('--datafile', '-d', type=click.Path(exists=True, file_okay=True, dir_okay=False, resolve_path=True, writable=True), required=True)
@click.option('--resolution', '-r', default=300)
@click.option('--compression', '-z', type=int, default=50)
@click.option('--yes', '-y', is_flag=True, type=bool, required=False, default=False, help='Answer yes to all prompt requests')
@click.pass_context
def correct(ctx, sorted_dir, corrected, datafile, resolution, compression, yes):  
    """
    Corrects a set of pages creating a (compressed) corrected pdf file and storing the correction data into a .json file
    """

    if os.path.exists(corrected):
        if yes or click.confirm("Corrected file {} exists, overwrite its content?".format(corrected), default=True):
            pass
        else:
            click.secho("Nothing done", fg='bright_yellow')
            sys.exit(0)

    corrector = Correct(sorted_dir, corrected, datafile, resolution, compression)
    corrector.correct()

@cli.command()
@click.argument('datafile', type=click.Path(exists=True, file_okay=True, dir_okay=False, resolve_path=True, writable=True), required=True)
@click.option('--output', '-o', type=click.Path(exists=False, file_okay=True, dir_okay=False, resolve_path=True, writable=True), required=True)
@click.option('--yes', '-y', is_flag=True, type=bool, required=False, default=False, help='Answer yes to all prompt requests')
@click.pass_context
def mark(ctx, datafile, output, yes):
    """
    Performs the marking of corrected exams and produces an excel file with the grading
    """
    if os.path.exists(output):
        if yes or click.confirm("Marking file {} exists, overwrite its content?".format(output), default=True):
            pass
        else:
            click.secho("Nothing done", fg='bright_yellow')
            sys.exit(0)

    marker = Mark(datafile, output)
    marker.mark()


@cli.command()
@click.argument('questions_dir', type=click.Path(exists=True, file_okay=False, resolve_path=True), default=os.path.join('.', 'questions'), required=True)
@click.option('-s', '--single', is_flag=True, default=False, help='State whether the questions have a single correct answer (a radio button will be rendered in moodle)')
@click.option('-p', '--penalty', type=int, help='Penalty (in percentage) to be applied to wrong answers')
@click.pass_context
def moodle(ctx, questions_dir, single, penalty):
    """
    Converts the questions database in the moodle XML format
    """
    moodle_converter = MoodleConverter(questions_dir, single, penalty)
    moodle_converter.convert()

@cli.command()
@click.argument('datafile', type=click.Path(exists=True, file_okay=True, dir_okay=False, resolve_path=True, writable=True), required=True)
@click.option('--output', '-o', type=click.Path(exists=False, file_okay=True, dir_okay=False, resolve_path=True, writable=True), required=True)
@click.option('--yes', '-y', is_flag=True, type=bool, required=False, default=False, help='Answer yes to all prompt requests')
@click.pass_context
def report(ctx, datafile, output, yes):
    with TinyDB(datafile) as db:
            df = pd.DataFrame()
            Exam = Query()
            for exam in db.table('correction').all():
                e = db.table('exams').get(Exam.student_id == exam['student_id'])
                correct_answers = list(map(set, exam['correct_answers']))
                given_answers = list(map(set, exam['given_answers']))
                question_size = list(map(lambda q: len(q[3]), e['questions']))
                for i in range(len(correct_answers)):
                    marked, correct, missing, wrong = given_answers[i], correct_answers[i] & given_answers[i], correct_answers[i] - given_answers[i], given_answers[i] - correct_answers[i]
                    df = pd.concat([df, pd.DataFrame([{ 'filename': e['questions'][i][0], 'question': e['questions'][i][1], 'correct_ratio': len(correct) / len(correct_answers[i]), 'missing_ratio': len(missing) / len(correct_answers[i]), 'wrong_ratio': len(wrong) / len(correct_answers[i]), 'options': question_size[i], 'no_correct_answers': len(correct_answers[i]) }])])                    
            df = df.groupby(['filename', 'question']).agg({ 'correct_ratio': ['count', 'sum', 'mean', 'std'], 'missing_ratio': ['mean', 'std'], 'wrong_ratio': ['mean', 'std'], 'options': 'min', 'no_correct_answers': 'min' })
            df.to_excel(output)
            
@cli.command()
@click.argument('datafile', type=click.Path(exists=True, file_okay=True, dir_okay=False, resolve_path=True, writable=True), required=True)
@click.argument('student_id', type=str, required=True)
@click.argument('question', type=int, required=True)
@click.argument('given_answers', type=str, required=True)
@click.pass_context
def force_answer(ctx, datafile, student_id, question, given_answers):
    """
    Forces the given answers for student_id and question. The answers should be expressed as a string without spaces, e.g. AEF
    """
    with TinyDB(datafile) as db:
        Exam = Query()
        exam = db.table('exams').get(Exam.student_id == student_id)
        correction = db.table('correction').get(Exam.student_id == student_id)
        try:
            given = correction['given_answers'][question - 1]
            new_given = list(given_answers.upper())
            if (set(given) == set(new_given)):
                click.secho(f"The current and the updated given answers for question {question} and student {student_id} are equal {set(given)}, nothing to do", fg="yellow")
                sys.exit(0)
            new_given_order = map(lambda l: ord(l) - ord('A'), new_given)
            question_size = len(exam['questions'][question -1][3])
            if any(o not in range(question_size) for o in new_given_order):
                click.secho(f"Question {question} for student {student_id} admits answers from 'A' to {chr(question_size - 1 + ord('A'))} but given {set(new_given)}", fg="red")
                sys.exit(-1)
            click.secho(f"Updating question {question} for student {student_id} with answers {set(new_given)} instead of {set(given)}", fg="green")
            correction['given_answers'][question - 1] = new_given
            db.table('correction').update(correction, where('student_id') == student_id)
        except IndexError:
            click.secho(f"Question {question} is not appearing in the list of given answers for student {student_id}", fg="red")
            sys.exit(-1)           

if __name__ == '__main__':
    cli(obj={})
